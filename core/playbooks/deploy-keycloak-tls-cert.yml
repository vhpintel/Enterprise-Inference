# Copyright (C) 2025-2026 Intel Corporation
# SPDX-License-Identifier: Apache-2.0
---
- name: Create Keycloak TLS secret
  hosts: "{{ inference_delegate | default('kube_control_plane') }}"
  gather_facts: false
  any_errors_fatal: "{{ any_errors_fatal | default(true) }}"
  environment: "{{ proxy_disable_env | default(env_proxy | default({})) }}"
  vars_files:
    - "{{ lookup('env', 'PWD') }}/config/vars/inference_common.yml"
    - "{{ lookup('env', 'PWD') }}/config/vars/inference_keycloak_apisix.yml"
  roles:
    - role: inference-tools
  tasks:
    - name: Create Namespace for APISIX
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: auth-apisix
    - name: Output variable values
      debug:
        var: cert_file, key_file, secret_name
    - name: Create TLS secret for Keycloak
      community.kubernetes.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: "{{ secret_name }}"
            namespace: default # Change this to the desired namespace if not default
          type: kubernetes.io/tls
          data:
            tls.crt: "{{ lookup('file', cert_file) | b64encode }}"
            tls.key: "{{ lookup('file', key_file) | b64encode }}"
      register: kubectl_output
    - name: Create TLS secret for Keycloak in APISIX namespace
      community.kubernetes.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: "{{ secret_name }}"
            namespace: auth-apisix # Change this to the desired namespace if not default
          type: kubernetes.io/tls
          data:
            tls.crt: "{{ lookup('file', cert_file) | b64encode }}"
            tls.key: "{{ lookup('file', key_file) | b64encode }}"
      register: kubectl_output
      when: deploy_apisix == "yes"
    - name: Display the output
      debug:
        msg: "Secret {{ secret_name }} created."
    - name: Retrieve number of Infrastructure Nodes (ei-infra-eligible)
      ansible.builtin.shell: kubectl get nodes --selector=ei-infra-eligible=true --no-headers | wc -l
      register: inference_node_count
      changed_when: false
    - name: Set Keycloak Replicas based upon Infrastructure Nodes
      set_fact:
        inference_infra_replica_count: "{{ inference_node_count.stdout | int if inference_node_count.stdout | int > 0 else 1 }}"
    - name: Display the number of Infrastructure Nodes
      debug:
        msg: "Number of ei-infra-eligible nodes configured: {{ inference_infra_replica_count }}"
      run_once: true
      when: deploy_keycloak == "yes"
    - name: Delete genai-gateway-ingress resource
      kubernetes.core.k8s:
        state: absent
        kind: Ingress
        name: genai-gateway-ingress
        namespace: genai-gateway
      ignore_errors: true
   
    - name: Deploy Keycloak System
      run_once: true
      register: helm_output
      when: deploy_keycloak == "yes"
      community.kubernetes.helm:
        name: keycloak
        chart_ref: oci://registry-1.docker.io/bitnamicharts/keycloak
        release_namespace: default # Set the namespace where Keycloak will be installed
        create_namespace: true
        chart_version: "{{ keycloak_chart_version|default('22.1.0') }}"
        values:
          image:
            repository: bitnamilegacy/keycloak
            tag: 25.0.2-debian-12-r2
          postgresql:
            image:
              repository: bitnamilegacy/postgresql
              tag: 16.3.0-debian-12-r23
            primary:
              podSecurityContext:
                enabled: true
                fsGroup: 1001
              containerSecurityContext:
                enabled: false
              persistence:
                enabled: true
                size: 8Gi
              tolerations:
                - key: node-role.kubernetes.io/control-plane
                  operator: Exists
                  effect: NoSchedule
                - key: node-role.kubernetes.io/master
                  operator: Exists
                  effect: NoSchedule
              affinity:
                nodeAffinity:
                  requiredDuringSchedulingIgnoredDuringExecution:
                    nodeSelectorTerms:
                    - matchExpressions:
                      - key: ei-infra-eligible
                        operator: In
                        values: ["true"]
            volumePermissions:
              enabled: true
              image:
                repository: bitnamilegacy/os-shell
                tag: 12-debian-12-r48
          production: true
          proxy: edge
          replicaCount: "{{ inference_infra_replica_count | int }}"
          resources:
            requests:
              memory: "2Gi"
              cpu: "500m"
            limits:
              memory: "4Gi"
              cpu: "1500m"
          extraEnvVars:
            - name: KC_CACHE
              value: ispn
            - name: KC_CACHE_STACK
              value: kubernetes
          auth:
            adminUser: "{{ keycloak_admin_user }}"
            adminPassword: "{{ keycloak_admin_password }}"
          metrics:
            enabled: true
          autoscaling:
            enabled: true
            minReplicas: "{{ inference_infra_replica_count | int }}"
            maxReplicas: "{{ (inference_infra_replica_count | int * 3) }}"
            metrics:
              - type: Resource
                resource:
                  name: cpu
                  targetAverageUtilization: 60
              - type: Resource
                resource:
                  name: memory
                  targetAverageUtilization: 60
          ingress:
            enabled: "{{ false if kubernetes_platform == 'openshift' or kubernetes_platform == 'eks' else true }}"
            hostname: "{{ secret_name }}"
            tls: true
            ingressClassName: "nginx"
            proxyAddressForwarding: true
            annotations:
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
              nginx.ingress.kubernetes.io/proxy-body-size: "10m"
            extraTls:
              - hosts:
                  - "{{ secret_name }}"
                secretName: "{{ secret_name }}"
          route:
            enabled: "{{ true if kubernetes_platform == 'openshift' else false }}"
            hostname: "{{ secret_name }}"
            tls:
              enabled: true
              termination: edge
              insecureEdgeTerminationPolicy: Redirect
          tolerations:
            - key: node-role.kubernetes.io/control-plane
              operator: Exists
              effect: NoSchedule
            - key: node-role.kubernetes.io/master
              operator: Exists
              effect: NoSchedule
          affinity:
            nodeAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                nodeSelectorTerms:
                - matchExpressions:
                  - key: ei-infra-eligible
                    operator: In
                    values: ["true"]
                - matchExpressions:
                  - key: node-role.kubernetes.io/control-plane
                    operator: Exists
            podAntiAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
                - weight: 100
                  podAffinityTerm:
                    labelSelector:
                      matchLabels:
                        app: keycloak
                    topologyKey: "kubernetes.io/hostname"
    - name: Verify Keycloak StatefulSet readiness
      community.kubernetes.k8s_info:
        kind: StatefulSet
        namespace: default
        name: keycloak
      register: keycloak_statefulset
      until: >
        keycloak_statefulset.resources[0].status.readyReplicas is defined and
        keycloak_statefulset.resources[0].status.readyReplicas == keycloak_statefulset.resources[0].spec.replicas
      retries: 60
      delay: 10
      changed_when: false
      when: deploy_keycloak == "yes"
    - name: Wait for Keycloak pods to be ready
      kubernetes.core.k8s_info:
        kind: Pod
        namespace: default
        label_selectors:
          - app.kubernetes.io/name=keycloak
      register: keycloak_pods
      until:
        - keycloak_pods.resources | length > 0
        - keycloak_pods.resources | selectattr('status.phase', 'equalto', 'Running') | list | length == keycloak_pods.resources | length
        - keycloak_pods.resources | map(attribute='status.containerStatuses') | flatten | selectattr('ready', 'equalto', true) | list | length == (keycloak_pods.resources | map(attribute='status.containerStatuses') | flatten | list | length)
      retries: 60
      delay: 10
      changed_when: false
      when: deploy_keycloak == "yes"

    - name: Wait for Keycloak service endpoint to be ready
      ansible.builtin.shell: |
        kubectl get endpoints keycloak -n default -o jsonpath='{.subsets[*].addresses[*].ip}' | grep -q .
      register: keycloak_endpoint
      until: keycloak_endpoint.rc == 0
      retries: 30
      delay: 10
      changed_when: false
      when: deploy_keycloak == "yes"

    - name: Wait for Keycloak token endpoint and authentication to be working
      ansible.builtin.shell: |
        kubectl exec -n default $(kubectl get pod -n default -l app.kubernetes.io/name=keycloak -o jsonpath='{.items[0].metadata.name}') -- \
          curl -X POST -w "%{http_code}" -o /dev/null -s \
          -d "client_id=admin-cli" \
          -d "username={{ keycloak_admin_user }}" \
          -d "password={{ keycloak_admin_password }}" \
          -d "grant_type=password" \
          http://localhost:8080/realms/master/protocol/openid-connect/token 2>/dev/null || echo "000"
      register: keycloak_token_health
      until: keycloak_token_health.stdout is defined and keycloak_token_health.stdout == "200"
      retries: 30
      delay: 5
      changed_when: false
      failed_when: false
      when: deploy_keycloak == "yes"

    - name: Wait for Keycloak admin API for client management to be ready
      ansible.builtin.shell: |
        TOKEN=$(kubectl exec -n default $(kubectl get pod -n default -l app.kubernetes.io/name=keycloak -o jsonpath='{.items[0].metadata.name}') -- \
          curl -s -X POST \
          -d "client_id=admin-cli" \
          -d "username={{ keycloak_admin_user }}" \
          -d "password={{ keycloak_admin_password }}" \
          -d "grant_type=password" \
          http://localhost:8080/realms/master/protocol/openid-connect/token 2>/dev/null | grep -o '"access_token":"[^"]*"' | cut -d'"' -f4)
        kubectl exec -n default $(kubectl get pod -n default -l app.kubernetes.io/name=keycloak -o jsonpath='{.items[0].metadata.name}') -- \
          curl -w "%{http_code}" -o /dev/null -s \
          -H "Authorization: Bearer $TOKEN" \
          http://localhost:8080/admin/realms/master/clients 2>/dev/null || echo "000"
      register: keycloak_admin_health
      until: keycloak_admin_health.stdout is defined and keycloak_admin_health.stdout == "200"
      retries: 30
      delay: 5
      changed_when: false
      failed_when: false
      when: deploy_keycloak == "yes"

    - name: Additional wait to ensure Keycloak realm API is stable
      ansible.builtin.pause:
        seconds: 15
      when: deploy_keycloak == "yes"

    - name: Create ALB Ingress for Keycloak on EKS
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: keycloak-ingress
            namespace: default
            annotations:
              alb.ingress.kubernetes.io/actions.ssl-redirect: '{"Type": "redirect", "RedirectConfig": { "Protocol": "HTTPS", "Port": "443", "StatusCode": "HTTP_301"}}'
              alb.ingress.kubernetes.io/certificate-arn: "{{ aws_certificate_arn | default('') }}"
              alb.ingress.kubernetes.io/group.name: ei-eks
              alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS": 443}]'
              alb.ingress.kubernetes.io/scheme: internet-facing
              alb.ingress.kubernetes.io/target-type: ip
              alb.ingress.kubernetes.io/group.order: '3'
          spec:
            ingressClassName: alb
            rules:
              - host: "{{ secret_name }}"
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: keycloak
                          port:
                            number: 80
            tls:
              - hosts:
                  - "{{ secret_name }}"
                secretName: "{{ secret_name }}"
      when: 
        - deploy_keycloak == "yes"
        - kubernetes_platform == "eks"

    - name: Ensure Remote Directory Exists
      ansible.builtin.file:
        path: "{{ remote_helm_charts_base }}"
        state: directory
        mode: "0755"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
      tags: always
    - name: Sync dependency files to Deployment Nodes
      ansible.posix.synchronize:
        src: "{{ item.src }}/"
        dest: "{{ item.dest }}/"
        recursive: yes
        delete: no
        mode: push
      loop:
        - {
            src: "{{ helm_charts_base }}",
            dest: "{{ remote_helm_charts_base }}/",
          }
        - {
            src: "{{ remote_home_dir }}",
            dest: "{{ remote_helm_charts_base }}/",
          }
      tags: always
    - name: Ensure Keycloak Realm Creation script is executable
      file:
        path: "{{ remote_helm_charts_base }}/keycloak-realmcreation.sh"
        mode: "0755"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
    - name: Use EKS-specific ingress configuration for Keycloak
      ansible.builtin.copy:
        src: "{{ remote_helm_charts_base }}/keycloak/templates/ingress_eks.yaml"
        dest: "{{ remote_helm_charts_base }}/keycloak/templates/ingress.yaml"
        remote_src: yes
      when: kubernetes_platform == "eks"
    - name: Remove duplicate EKS ingress template for Keycloak
      ansible.builtin.file:
        path: "{{ remote_helm_charts_base }}/keycloak/templates/ingress_eks.yaml"
        state: absent
      when: kubernetes_platform == "eks"
    - name: Remove EKS ingress template when not on EKS
      ansible.builtin.file:
        path: "{{ remote_helm_charts_base }}/keycloak/templates/ingress_eks.yaml"
        state: absent
      when: kubernetes_platform != "eks"
    - name: Synchronize dependencies for APISIX
      ansible.builtin.command: helm dependency update "{{ remote_helm_charts_base }}/apisix-helm/"
      register: helm_dependency_update
      failed_when: helm_dependency_update.rc != 0
      when: deploy_apisix == "yes"
    - name: Synchronize dependencies for APISIX
      community.kubernetes.helm:
        name: auth-apisix
        chart_ref: "{{ remote_helm_charts_base }}/apisix-helm/"
        update_repo_cache: yes
        release_namespace: auth-apisix
      run_once: true
      when: deploy_apisix == "yes"
    - name: Deploy APISIX System
      command: >
        helm upgrade --install auth-apisix {{ remote_helm_charts_base }}/apisix-helm/
        --values {{ remote_helm_charts_base }}/apisix-helm/{% if kubernetes_platform == 'openshift' %}openshift-values.yaml{% else %}values.yaml{% endif %}
        --set apisix.replicaCount={{ inference_infra_replica_count }}
        --set apisix.ingress-controller.replicaCount={{ inference_infra_replica_count }}
        --set apisix.etcd.replicaCount={{ inference_infra_replica_count }}
        --namespace auth-apisix --create-namespace
      when: deploy_apisix == "yes"
      run_once: true

    - name: Add SCC policy to auth-apisix service account
      command: oc adm policy add-scc-to-user anyuid -z auth-apisix -n auth-apisix
      when: 
        - deploy_apisix == "yes"
        - kubernetes_platform == "openshift"
      run_once: true
      ignore_errors: true
    
    - name: Restart auth-apisix deployment after SCC policy change
      command: kubectl rollout restart deployment/auth-apisix -n auth-apisix
      when:
        - deploy_apisix == "yes"
        - kubernetes_platform == "openshift"
      run_once: true
      ignore_errors: true
    
    - name: Add SCC policy to auth-apisix-etcd service account
      command: oc adm policy add-scc-to-user anyuid -z auth-apisix-etcd -n auth-apisix
      when: 
        - deploy_apisix == "yes"
        - kubernetes_platform == "openshift"
      run_once: true
      ignore_errors: true
    
    - name: Restart auth-apisix pods to apply SCC changes
      command: kubectl rollout restart statefulset -n auth-apisix
      when:
        - deploy_apisix == "yes"
        - kubernetes_platform == "openshift"
      run_once: true
      ignore_errors: true
    - name: Wait for APISIX pods to be ready
      kubernetes.core.k8s_info:
        kind: Pod
        namespace: auth-apisix
        label_selectors:
          - app.kubernetes.io/instance=auth-apisix
      register: apisix_pods
      until:
        - apisix_pods.resources | length > 0
        - apisix_pods.resources | selectattr('status.phase', 'equalto', 'Running') | list | length == apisix_pods.resources | length
        - apisix_pods.resources | map(attribute='status.containerStatuses') | flatten | selectattr('ready', 'equalto', true) | list | length == (apisix_pods.resources | map(attribute='status.containerStatuses') | flatten | list | length)
      retries: 60
      delay: 10
      changed_when: false
      when: deploy_apisix == "yes"
    - name: Print Model List to be Deployed
      debug:
        var: model_name_list
    - name: Upgrade Keycloak with TLS and Ingress Configurations
      command: >
        helm upgrade --install keycloak-apisix "{{ remote_helm_charts_base }}/keycloak"
        --namespace default
        --set keycloakTokenRoute.host={{ secret_name }}
        --set keycloakTokenRoute.path=/token
        --set keycloakTokenRoute.serviceName=keycloak
        --set keycloakTokenRoute.servicePort=80
        --set keycloakTokenRoute.rewritePath=/realms/master/protocol/openid-connect/token
        --set tls.host={{ secret_name }}
        --set tls.secretName={{ secret_name }}
        --set tls.secretNamespace=default
        --set ingress.host={{ secret_name }}
        --set ingress.serviceName=auth-apisix-gateway
        --set ingress.servicePort=80
        --set ingress.secretName={{ secret_name }}
        {% if kubernetes_platform == 'openshift' %}
        --set route.enabled=true
        --set route.host={{ secret_name }}
        --set route.tls.termination=edge
        --set route.servicePort=80
        --set route.serviceName=auth-apisix-gateway
        --set route.tls.insecureEdgeTerminationPolicy=Redirect
        {% else %}
        --set route.enabled=false
        --set ingress.host={{ secret_name }}
        --set ingress.serviceName=auth-apisix-gateway
        --set ingress.servicePort=80
        --set ingress.secretName={{ secret_name }}
        {% endif %}
      environment:
        secret_name: "{{ secret_name }}"
      run_once: true
      register: keycloak_ingress_register_msg_in
      failed_when: keycloak_ingress_register_msg_in.rc != 0
      when: deploy_keycloak == "yes"

    - name: Create ConfigMap with Keycloak realm creation script
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: keycloak-realm-script
            namespace: default
          data:
            keycloak-realmcreation.sh: "{{ lookup('file', remote_home_dir + '/keycloak-realmcreation.sh') }}"
      run_once: true
      when: deploy_keycloak == "yes"

    - name: Create Keycloak realm setup Job
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: keycloak-realm-setup
            namespace: default
          spec:
            ttlSecondsAfterFinished: 300
            backoffLimit: 3
            template:
              metadata:
                name: keycloak-realm-setup
              spec:
                restartPolicy: Never
                containers:
                - name: keycloak-setup
                  image: ubuntu:22.04
                  command: ["/bin/bash", "-c"]
                  args:
                    - |
                      set -e
                      
                      # Install dependencies
                      apt-get update -qq
                      apt-get install -y -qq curl jq
                      
                      # Copy script to writable location
                      cp /scripts/keycloak-realmcreation.sh /tmp/keycloak-realmcreation.sh
                      chmod +x /tmp/keycloak-realmcreation.sh
                      
                      # Retry mechanism for Keycloak availability
                      MAX_RETRIES=30
                      RETRY_DELAY=10
                      RETRY_COUNT=0
                      
                      echo "Waiting for Keycloak to be ready..."
                      while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
                        # Test token endpoint
                        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
                          -d "client_id=admin-cli" \
                          -d "username={{ keycloak_admin_user }}" \
                          -d "password={{ keycloak_admin_password }}" \
                          -d "grant_type=password" \
                          http://keycloak.default.svc.cluster.local:80/realms/master/protocol/openid-connect/token || echo "000")
                        
                        if [ "$HTTP_CODE" = "200" ]; then
                          echo "Keycloak is ready (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
                          break
                        fi
                        
                        RETRY_COUNT=$((RETRY_COUNT + 1))
                        if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                          echo "Keycloak not ready yet (attempt $RETRY_COUNT/$MAX_RETRIES, HTTP: $HTTP_CODE). Retrying in ${RETRY_DELAY}s..."
                          sleep $RETRY_DELAY
                        else
                          echo "ERROR: Keycloak failed to become ready after $MAX_RETRIES attempts"
                          exit 1
                        fi
                      done
                      
                      # Additional stability wait
                      echo "Waiting 15 seconds for Keycloak to stabilize..."
                      sleep 15
                      
                      # Run the script with internal service name
                      echo "Running realm creation script..."
                      /tmp/keycloak-realmcreation.sh \
                        keycloak.default.svc.cluster.local:80 \
                        "{{ keycloak_admin_user }}" \
                        "{{ keycloak_admin_password }}" \
                        "{{ keycloak_client_id }}"
                  volumeMounts:
                  - name: scripts
                    mountPath: /scripts
                    readOnly: true
                volumes:
                - name: scripts
                  configMap:
                    name: keycloak-realm-script
                    defaultMode: 0755
                tolerations:
                  - key: node-role.kubernetes.io/control-plane
                    operator: Exists
                    effect: NoSchedule
                  - key: node-role.kubernetes.io/master
                    operator: Exists
                    effect: NoSchedule
      run_once: true
      when: deploy_keycloak == "yes"

    - name: Wait for Keycloak realm setup Job to complete
      kubernetes.core.k8s_info:
        kind: Job
        namespace: default
        name: keycloak-realm-setup
      register: realm_job
      until: >
        realm_job.resources[0].status.succeeded is defined and
        realm_job.resources[0].status.succeeded == 1
      retries: 30
      delay: 10
      run_once: true
      when: deploy_keycloak == "yes"

    - name: Get Keycloak realm setup Job logs
      command: kubectl logs job/keycloak-realm-setup -n default
      register: script_output
      run_once: true
      environment:
        http_proxy: ""
        https_proxy: ""
        no_proxy: ""
      when: deploy_keycloak == "yes"

    - name: Set client_secret fact
      set_fact:
        client_secret: "{{ script_output.stdout | regex_search('Client secret: (.*)') | join('') | regex_replace('^Client secret: ') }}"
      when:
        - script_output is defined
        - script_output.stdout is defined
        - script_output.stdout is search('Client secret:')
        - deploy_keycloak == "yes"
      run_once: true

    - name: Verify Keycloak ApisixRoute is synced
      shell: |
        kubectl get apisixroute keycloak-apisix-keycloak-token-route -n default -o jsonpath='{.status.conditions[?(@.type=="ResourcesAvailable")].status}' 2>/dev/null || echo "NotFound"
      register: apisixroute_status
      until: apisixroute_status.stdout == "True"
      retries: 15
      delay: 4
      failed_when: false
      when: 
        - deploy_keycloak == "yes"
        - deploy_apisix == "yes"
        - kubernetes_platform == "openshift"
      run_once: true

    - name: Force Keycloak ApisixRoute resync if verification failed
      shell: |
        ROUTE_NAME="keycloak-apisix-keycloak-token-route"
        if kubectl get apisixroute $ROUTE_NAME -n default >/dev/null 2>&1; then
          echo "Forcing resync by recreating the route..."
          kubectl get apisixroute $ROUTE_NAME -n default -o yaml > /tmp/keycloak-route.yaml
          kubectl delete apisixroute $ROUTE_NAME -n default
          sleep 2
          kubectl apply -f /tmp/keycloak-route.yaml
          rm -f /tmp/keycloak-route.yaml
          echo "Route recreated"
        else
          echo "Route not found, skipping resync"
        fi
      when: 
        - deploy_keycloak == "yes"
        - deploy_apisix == "yes"
        - kubernetes_platform == "openshift"
        - apisixroute_status.stdout != "True"
      run_once: true

    - name: Remove any existing deployment directory
      ansible.builtin.file:
        path: "{{ remote_helm_charts_base }}"
        state: absent
